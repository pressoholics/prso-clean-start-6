(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var liquidmetal=require("liquidmetal");onmessage=function(e){var r=(new Date).getTime(),t=e.data.query,n=e.data.index,a=t.replace(/\//g," ").toUpperCase().trim(),i=n.map(function(e){try{var r=e.description.indexOf(" ",16),t=e.search_source||[e.path_labeled.replace(/\//g," "),e.group,e.description.substring(0,r)].join(" ").toUpperCase().trim(),n=liquidmetal.score(t,a);return e.search_source=t,[n,t,e]}catch(r){return console&&console.warn&&console.warn("Failed to score endpoint",e,r.message),[0,"",e]}}).filter(function(e){return e[0]>0}).sort(function(e,r){return e[0]==r[0]?0:e[0]>r[0]?-1:1}),o=i.map(function(e){return e[2]}),s=(new Date).getTime();postMessage({query:t,results:o,ms:s-r})};

},{"liquidmetal":2}],2:[function(require,module,exports){
/**
 * LiquidMetal, version: 1.3.0 (2014-08-19)
 *
 * A mimetic poly-alloy of Quicksilver's scoring algorithm, essentially
 * LiquidMetal.
 *
 * For usage and examples, visit:
 * http://github.com/rmm5t/liquidmetal
 *
 * Licensed under the MIT:
 * http://www.opensource.org/licenses/mit-license.php
 *
 * Copyright (c) 2009-2014, Ryan McGeary (ryan -[at]- mcgeary [*dot*] org)
 */
(function(global) {
  var SCORE_NO_MATCH = 0.0;
  var SCORE_MATCH = 1.0;
  var SCORE_TRAILING = 0.8;
  var SCORE_TRAILING_BUT_STARTED = 0.9;
  var SCORE_BUFFER = 0.85;
  var WORD_SEPARATORS = " \t_-";

  var LiquidMetal = {
    lastScore: null,
    lastScoreArray: null,

    score: function(string, abbrev) {
      // short circuits
      if (abbrev.length === 0) return SCORE_TRAILING;
      if (abbrev.length > string.length) return SCORE_NO_MATCH;

      // match & score all
      var allScores = [];
      var search = string.toLowerCase();
      abbrev = abbrev.toLowerCase();
      this._scoreAll(string, search, abbrev, -1, 0, [], allScores);

      // complete miss
      if (allScores.length == 0) return 0;

      // sum per-character scores into overall scores,
      // selecting the maximum score
      var maxScore = 0.0, maxArray = [];
      for (var i = 0; i < allScores.length; i++) {
        var scores = allScores[i];
        var scoreSum = 0.0;
        for (var j = 0; j < string.length; j++) { scoreSum += scores[j]; }
        if (scoreSum > maxScore) {
          maxScore = scoreSum;
          maxArray = scores;
        }
      }

      // normalize max score by string length
      // s. t. the perfect match score = 1
      maxScore /= string.length;

      // record maximum score & score array, return
      this.lastScore = maxScore;
      this.lastScoreArray = maxArray;
      return maxScore;
    },

    _scoreAll: function(string, search, abbrev, searchIndex, abbrIndex, scores, allScores) {
      // save completed match scores at end of search
      if (abbrIndex == abbrev.length) {
        // add trailing score for the remainder of the match
        var started = (search.charAt(0) == abbrev.charAt(0));
        var trailScore = started ? SCORE_TRAILING_BUT_STARTED : SCORE_TRAILING;
        fillArray(scores, trailScore, scores.length, string.length);
        // save score clone (since reference is persisted in scores)
        allScores.push(scores.slice(0));
        return;
      }

      // consume current char to match
      var c = abbrev.charAt(abbrIndex);
      abbrIndex++;

      // cancel match if a character is missing
      var index = search.indexOf(c, searchIndex);
      if (index == -1) return;

      // match all instances of the abbreviaton char
      var scoreIndex = searchIndex; // score section to update
      while ((index = search.indexOf(c, searchIndex+1)) != -1) {
        // score this match according to context
        if (isNewWord(string, index)) {
          scores[index-1] = 1;
          fillArray(scores, SCORE_BUFFER, scoreIndex+1, index-1);
        }
        else if (isUpperCase(string, index)) {
          fillArray(scores, SCORE_BUFFER, scoreIndex+1, index);
        }
        else {
          fillArray(scores, SCORE_NO_MATCH, scoreIndex+1, index);
        }
        scores[index] = SCORE_MATCH;

        // consume matched string and continue search
        searchIndex = index;
        this._scoreAll(string, search, abbrev, searchIndex, abbrIndex, scores, allScores);
      }
    }
  };

  function isUpperCase(string, index) {
    var c = string.charAt(index);
    return ("A" <= c && c <= "Z");
  }

   function isNewWord(string, index) {
    var c = string.charAt(index-1);
    return (WORD_SEPARATORS.indexOf(c) != -1);
  }

  function fillArray(array, value, from, to) {
    for (var i = from; i < to; i++) { array[i] = value; }
    return array;
  }

  // Export as AMD...
  if (typeof define === 'function' && define.amd) {
    define(function () { return LiquidMetal; });
  }

  // ...or as a node module
  else if (typeof module !== 'undefined' && module.exports) {
    module.exports = LiquidMetal;
  }

  else {
    global.LiquidMetal = LiquidMetal;
  }
})(typeof window !== 'undefined' ? window : this);

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJsaWIvc2VhcmNoLmpzIiwibm9kZV9tb2R1bGVzL2xpcXVpZG1ldGFsL2xpcXVpZG1ldGFsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUEsR0FBSSxhQUFjLFFBQVEsY0FHMUIsV0FBWSxTQUFTLEdBRW5CLEdBQUksSUFBUSxHQUFJLE9BQU8sVUFDbkIsRUFBUSxFQUFFLEtBQUssTUFDZixFQUFRLEVBQUUsS0FBSyxNQUNmLEVBQU8sRUFBTSxRQUFRLE1BQU8sS0FBSyxjQUFjLE9BQy9DLEVBQVMsRUFBTSxJQUFJLFNBQVMsR0FFMUIsSUFDRSxHQUFJLEdBQUksRUFBUyxZQUFZLFFBQVEsSUFBSyxJQUN0QyxFQUFTLEVBQVMsZ0JBQWtCLEVBQVMsYUFBYSxRQUFRLE1BQU8sS0FBTSxFQUFTLE1BQU8sRUFBUyxZQUFZLFVBQVUsRUFBRSxJQUFJLEtBQUssS0FBSyxjQUFjLE9BQzVKLEVBQVEsWUFBWSxNQUFNLEVBQVEsRUFFbEMsT0FEQSxHQUFTLGNBQWdCLEdBQ2pCLEVBQU8sRUFBUSxHQUMzQixNQUFPLEdBSVAsTUFISSxVQUFXLFFBQVEsTUFDckIsUUFBUSxLQUFLLDJCQUE0QixFQUFVLEVBQU0sVUFFbkQsRUFBRyxHQUFJLE1BR2hCLE9BQU8sU0FBUyxHQUNqQixNQUFPLEdBQU0sR0FBSyxJQUNqQixLQUFLLFNBQVMsRUFBRyxHQUNsQixNQUFJLEdBQUUsSUFBTSxFQUFFLEdBQVcsRUFFckIsRUFBRSxHQUFLLEVBQUUsSUFBVyxFQUVqQixJQUdULEVBQVUsRUFBTyxJQUFJLFNBQVMsR0FBSSxNQUFPLEdBQUUsS0FDM0MsR0FBTSxHQUFJLE9BQU8sU0FFckIsY0FBYSxNQUFPLEVBQU8sUUFBUyxFQUFTLEdBQUksRUFBSTs7O0FDckN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJ2YXIgbGlxdWlkbWV0YWwgPSByZXF1aXJlKCdsaXF1aWRtZXRhbCcpO1xuXG5cbm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcblxuICB2YXIgc3RhcnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcbiAgICAgIHF1ZXJ5ID0gZS5kYXRhLnF1ZXJ5LFxuICAgICAgaW5kZXggPSBlLmRhdGEuaW5kZXgsXG4gICAgICB0ZXJtID0gcXVlcnkucmVwbGFjZSgvXFwvL2csICcgJykudG9VcHBlckNhc2UoKS50cmltKCksXG4gICAgICByYW5rZWQgPSBpbmRleC5tYXAoZnVuY3Rpb24oZW5kcG9pbnQpIHtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBpID0gZW5kcG9pbnQuZGVzY3JpcHRpb24uaW5kZXhPZihcIiBcIiwgMTYpLFxuICAgICAgICAgICAgICBzb3VyY2UgPSBlbmRwb2ludC5zZWFyY2hfc291cmNlIHx8IFtlbmRwb2ludC5wYXRoX2xhYmVsZWQucmVwbGFjZSgvXFwvL2csICcgJyksIGVuZHBvaW50Lmdyb3VwLCBlbmRwb2ludC5kZXNjcmlwdGlvbi5zdWJzdHJpbmcoMCxpKV0uam9pbignICcpLnRvVXBwZXJDYXNlKCkudHJpbSgpLFxuICAgICAgICAgICAgICBzY29yZSA9IGxpcXVpZG1ldGFsLnNjb3JlKHNvdXJjZSwgdGVybSk7XG4gICAgICAgICAgICAgIGVuZHBvaW50LnNlYXJjaF9zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgICAgICAgIHJldHVybiBbc2NvcmUsIHNvdXJjZSwgZW5kcG9pbnRdO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIHNjb3JlIGVuZHBvaW50XCIsIGVuZHBvaW50LCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFswLCAnJywgZW5kcG9pbnRdO1xuICAgICAgICB9XG5cbiAgICAgIH0pLmZpbHRlcihmdW5jdGlvbihzY29yZSl7XG4gICAgICAgIHJldHVybiBzY29yZVswXSA+IDA7XG4gICAgICB9KS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgaWYgKGFbMF0gPT0gYlswXSkgcmV0dXJuIDA7XG5cbiAgICAgICAgaWYgKGFbMF0gPiBiWzBdKSByZXR1cm4gLTE7XG5cbiAgICAgICAgcmV0dXJuIDE7XG5cbiAgICAgIH0pLFxuICAgICAgcmVzdWx0cyA9IHJhbmtlZC5tYXAoZnVuY3Rpb24oZSl7IHJldHVybiBlWzJdOyB9KSxcbiAgICAgIGVuZCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gIHBvc3RNZXNzYWdlKHtxdWVyeTogcXVlcnksIHJlc3VsdHM6IHJlc3VsdHMsIG1zOiBlbmQtc3RhcnR9KTtcbn07XG5cbiIsIi8qKlxuICogTGlxdWlkTWV0YWwsIHZlcnNpb246IDEuMy4wICgyMDE0LTA4LTE5KVxuICpcbiAqIEEgbWltZXRpYyBwb2x5LWFsbG95IG9mIFF1aWNrc2lsdmVyJ3Mgc2NvcmluZyBhbGdvcml0aG0sIGVzc2VudGlhbGx5XG4gKiBMaXF1aWRNZXRhbC5cbiAqXG4gKiBGb3IgdXNhZ2UgYW5kIGV4YW1wbGVzLCB2aXNpdDpcbiAqIGh0dHA6Ly9naXRodWIuY29tL3JtbTV0L2xpcXVpZG1ldGFsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVDpcbiAqIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDA5LTIwMTQsIFJ5YW4gTWNHZWFyeSAocnlhbiAtW2F0XS0gbWNnZWFyeSBbKmRvdCpdIG9yZylcbiAqL1xuKGZ1bmN0aW9uKGdsb2JhbCkge1xuICB2YXIgU0NPUkVfTk9fTUFUQ0ggPSAwLjA7XG4gIHZhciBTQ09SRV9NQVRDSCA9IDEuMDtcbiAgdmFyIFNDT1JFX1RSQUlMSU5HID0gMC44O1xuICB2YXIgU0NPUkVfVFJBSUxJTkdfQlVUX1NUQVJURUQgPSAwLjk7XG4gIHZhciBTQ09SRV9CVUZGRVIgPSAwLjg1O1xuICB2YXIgV09SRF9TRVBBUkFUT1JTID0gXCIgXFx0Xy1cIjtcblxuICB2YXIgTGlxdWlkTWV0YWwgPSB7XG4gICAgbGFzdFNjb3JlOiBudWxsLFxuICAgIGxhc3RTY29yZUFycmF5OiBudWxsLFxuXG4gICAgc2NvcmU6IGZ1bmN0aW9uKHN0cmluZywgYWJicmV2KSB7XG4gICAgICAvLyBzaG9ydCBjaXJjdWl0c1xuICAgICAgaWYgKGFiYnJldi5sZW5ndGggPT09IDApIHJldHVybiBTQ09SRV9UUkFJTElORztcbiAgICAgIGlmIChhYmJyZXYubGVuZ3RoID4gc3RyaW5nLmxlbmd0aCkgcmV0dXJuIFNDT1JFX05PX01BVENIO1xuXG4gICAgICAvLyBtYXRjaCAmIHNjb3JlIGFsbFxuICAgICAgdmFyIGFsbFNjb3JlcyA9IFtdO1xuICAgICAgdmFyIHNlYXJjaCA9IHN0cmluZy50b0xvd2VyQ2FzZSgpO1xuICAgICAgYWJicmV2ID0gYWJicmV2LnRvTG93ZXJDYXNlKCk7XG4gICAgICB0aGlzLl9zY29yZUFsbChzdHJpbmcsIHNlYXJjaCwgYWJicmV2LCAtMSwgMCwgW10sIGFsbFNjb3Jlcyk7XG5cbiAgICAgIC8vIGNvbXBsZXRlIG1pc3NcbiAgICAgIGlmIChhbGxTY29yZXMubGVuZ3RoID09IDApIHJldHVybiAwO1xuXG4gICAgICAvLyBzdW0gcGVyLWNoYXJhY3RlciBzY29yZXMgaW50byBvdmVyYWxsIHNjb3JlcyxcbiAgICAgIC8vIHNlbGVjdGluZyB0aGUgbWF4aW11bSBzY29yZVxuICAgICAgdmFyIG1heFNjb3JlID0gMC4wLCBtYXhBcnJheSA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxTY29yZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNjb3JlcyA9IGFsbFNjb3Jlc1tpXTtcbiAgICAgICAgdmFyIHNjb3JlU3VtID0gMC4wO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN0cmluZy5sZW5ndGg7IGorKykgeyBzY29yZVN1bSArPSBzY29yZXNbal07IH1cbiAgICAgICAgaWYgKHNjb3JlU3VtID4gbWF4U2NvcmUpIHtcbiAgICAgICAgICBtYXhTY29yZSA9IHNjb3JlU3VtO1xuICAgICAgICAgIG1heEFycmF5ID0gc2NvcmVzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG5vcm1hbGl6ZSBtYXggc2NvcmUgYnkgc3RyaW5nIGxlbmd0aFxuICAgICAgLy8gcy4gdC4gdGhlIHBlcmZlY3QgbWF0Y2ggc2NvcmUgPSAxXG4gICAgICBtYXhTY29yZSAvPSBzdHJpbmcubGVuZ3RoO1xuXG4gICAgICAvLyByZWNvcmQgbWF4aW11bSBzY29yZSAmIHNjb3JlIGFycmF5LCByZXR1cm5cbiAgICAgIHRoaXMubGFzdFNjb3JlID0gbWF4U2NvcmU7XG4gICAgICB0aGlzLmxhc3RTY29yZUFycmF5ID0gbWF4QXJyYXk7XG4gICAgICByZXR1cm4gbWF4U2NvcmU7XG4gICAgfSxcblxuICAgIF9zY29yZUFsbDogZnVuY3Rpb24oc3RyaW5nLCBzZWFyY2gsIGFiYnJldiwgc2VhcmNoSW5kZXgsIGFiYnJJbmRleCwgc2NvcmVzLCBhbGxTY29yZXMpIHtcbiAgICAgIC8vIHNhdmUgY29tcGxldGVkIG1hdGNoIHNjb3JlcyBhdCBlbmQgb2Ygc2VhcmNoXG4gICAgICBpZiAoYWJickluZGV4ID09IGFiYnJldi5sZW5ndGgpIHtcbiAgICAgICAgLy8gYWRkIHRyYWlsaW5nIHNjb3JlIGZvciB0aGUgcmVtYWluZGVyIG9mIHRoZSBtYXRjaFxuICAgICAgICB2YXIgc3RhcnRlZCA9IChzZWFyY2guY2hhckF0KDApID09IGFiYnJldi5jaGFyQXQoMCkpO1xuICAgICAgICB2YXIgdHJhaWxTY29yZSA9IHN0YXJ0ZWQgPyBTQ09SRV9UUkFJTElOR19CVVRfU1RBUlRFRCA6IFNDT1JFX1RSQUlMSU5HO1xuICAgICAgICBmaWxsQXJyYXkoc2NvcmVzLCB0cmFpbFNjb3JlLCBzY29yZXMubGVuZ3RoLCBzdHJpbmcubGVuZ3RoKTtcbiAgICAgICAgLy8gc2F2ZSBzY29yZSBjbG9uZSAoc2luY2UgcmVmZXJlbmNlIGlzIHBlcnNpc3RlZCBpbiBzY29yZXMpXG4gICAgICAgIGFsbFNjb3Jlcy5wdXNoKHNjb3Jlcy5zbGljZSgwKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gY29uc3VtZSBjdXJyZW50IGNoYXIgdG8gbWF0Y2hcbiAgICAgIHZhciBjID0gYWJicmV2LmNoYXJBdChhYmJySW5kZXgpO1xuICAgICAgYWJickluZGV4Kys7XG5cbiAgICAgIC8vIGNhbmNlbCBtYXRjaCBpZiBhIGNoYXJhY3RlciBpcyBtaXNzaW5nXG4gICAgICB2YXIgaW5kZXggPSBzZWFyY2guaW5kZXhPZihjLCBzZWFyY2hJbmRleCk7XG4gICAgICBpZiAoaW5kZXggPT0gLTEpIHJldHVybjtcblxuICAgICAgLy8gbWF0Y2ggYWxsIGluc3RhbmNlcyBvZiB0aGUgYWJicmV2aWF0b24gY2hhclxuICAgICAgdmFyIHNjb3JlSW5kZXggPSBzZWFyY2hJbmRleDsgLy8gc2NvcmUgc2VjdGlvbiB0byB1cGRhdGVcbiAgICAgIHdoaWxlICgoaW5kZXggPSBzZWFyY2guaW5kZXhPZihjLCBzZWFyY2hJbmRleCsxKSkgIT0gLTEpIHtcbiAgICAgICAgLy8gc2NvcmUgdGhpcyBtYXRjaCBhY2NvcmRpbmcgdG8gY29udGV4dFxuICAgICAgICBpZiAoaXNOZXdXb3JkKHN0cmluZywgaW5kZXgpKSB7XG4gICAgICAgICAgc2NvcmVzW2luZGV4LTFdID0gMTtcbiAgICAgICAgICBmaWxsQXJyYXkoc2NvcmVzLCBTQ09SRV9CVUZGRVIsIHNjb3JlSW5kZXgrMSwgaW5kZXgtMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNVcHBlckNhc2Uoc3RyaW5nLCBpbmRleCkpIHtcbiAgICAgICAgICBmaWxsQXJyYXkoc2NvcmVzLCBTQ09SRV9CVUZGRVIsIHNjb3JlSW5kZXgrMSwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGZpbGxBcnJheShzY29yZXMsIFNDT1JFX05PX01BVENILCBzY29yZUluZGV4KzEsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBzY29yZXNbaW5kZXhdID0gU0NPUkVfTUFUQ0g7XG5cbiAgICAgICAgLy8gY29uc3VtZSBtYXRjaGVkIHN0cmluZyBhbmQgY29udGludWUgc2VhcmNoXG4gICAgICAgIHNlYXJjaEluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuX3Njb3JlQWxsKHN0cmluZywgc2VhcmNoLCBhYmJyZXYsIHNlYXJjaEluZGV4LCBhYmJySW5kZXgsIHNjb3JlcywgYWxsU2NvcmVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gaXNVcHBlckNhc2Uoc3RyaW5nLCBpbmRleCkge1xuICAgIHZhciBjID0gc3RyaW5nLmNoYXJBdChpbmRleCk7XG4gICAgcmV0dXJuIChcIkFcIiA8PSBjICYmIGMgPD0gXCJaXCIpO1xuICB9XG5cbiAgIGZ1bmN0aW9uIGlzTmV3V29yZChzdHJpbmcsIGluZGV4KSB7XG4gICAgdmFyIGMgPSBzdHJpbmcuY2hhckF0KGluZGV4LTEpO1xuICAgIHJldHVybiAoV09SRF9TRVBBUkFUT1JTLmluZGV4T2YoYykgIT0gLTEpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlsbEFycmF5KGFycmF5LCB2YWx1ZSwgZnJvbSwgdG8pIHtcbiAgICBmb3IgKHZhciBpID0gZnJvbTsgaSA8IHRvOyBpKyspIHsgYXJyYXlbaV0gPSB2YWx1ZTsgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8vIEV4cG9ydCBhcyBBTUQuLi5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7IHJldHVybiBMaXF1aWRNZXRhbDsgfSk7XG4gIH1cblxuICAvLyAuLi5vciBhcyBhIG5vZGUgbW9kdWxlXG4gIGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBMaXF1aWRNZXRhbDtcbiAgfVxuXG4gIGVsc2Uge1xuICAgIGdsb2JhbC5MaXF1aWRNZXRhbCA9IExpcXVpZE1ldGFsO1xuICB9XG59KSh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHRoaXMpO1xuIl19
